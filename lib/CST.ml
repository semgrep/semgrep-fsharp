(* Generated by ocaml-tree-sitter. *)
(*
   fsharp grammar

   entrypoint: file
*)

open! Sexplib.Conv
open Tree_sitter_run

type imm_tok_choice_ul_ = Token.t

type range_op_name = [
    `DOTDOT of Token.t (* ".." *)
  | `DOTDOTSPACEDOTDOT of Token.t (* ".. .." *)
]

type imm_tok_choice_ul = Token.t

type imm_tok_dquot = Token.t (* "\"" *)

type imm_tok_lpar = Token.t (* "(" *)

type quote_op_left = [
    `LTAT of Token.t (* "<@" *)
  | `LTATAT of Token.t (* "<@@" *)
]

type bitdigit_imm = Token.t (* pattern [0-1] *)

type imm_tok_hash = Token.t (* "#" *)

type pat_c3eb998 =
  Token.t (* pattern "[_\\p{XID_Start}][_'\\p{XID_Continue}]*" *)

type imm_tok_squot = Token.t (* "'" *)

type virtual_open_section = Token.t

type pat_0b = Token.t (* pattern 0[bB] *)

type imm_tok_dquotdquotdquot = Token.t (* "\"\"\"" *)

type infix_or_prefix_op = [
    `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
  | `PLUSDOT of Token.t (* "+." *)
  | `DASHDOT of Token.t (* "-." *)
  | `PERC of Token.t (* "%" *)
  | `AMP of Token.t (* "&" *)
  | `AMPAMP of Token.t (* "&&" *)
]

type imm_tok_squotb = Token.t (* "'B" *)

type imm_tok_l = Token.t (* "l" *)

type imm_tok_s = Token.t (* "s" *)

type pat_9d988a2 = Token.t (* pattern ``([^`\n\r\t])+`` *)

type pat_0x = Token.t (* pattern 0[xX] *)

type attribute_target = [
    `Asse of Token.t (* "assembly" *)
  | `Module of Token.t (* "module" *)
  | `Ret of Token.t (* "return" *)
  | `Field of Token.t (* "field" *)
  | `Prop of Token.t (* "property" *)
  | `Param of Token.t (* "param" *)
  | `Type of Token.t (* "type" *)
  | `Cons of Token.t (* "constructor" *)
  | `Event of Token.t (* "event" *)
]

type imm_tok_lt = Token.t (* "<" *)

type imm_tok_dot = Token.t (* "." *)

type quote_op_right = [
    `ATGT of Token.t (* "@>" *)
  | `ATATGT of Token.t (* "@@>" *)
]

type digit_char_imm = Token.t (* pattern [0-9] *)

type block_comment_content = Token.t

type imm_tok_pat_m = Token.t (* pattern [Mm] *)

type imm_tok_f = Token.t (* "f" *)

type imm_tok_lf = Token.t (* "lf" *)

type virtual_end_decl = Token.t

type imm_tok_lbrack = Token.t (* "[" *)

type simple_string_char =
  Token.t (* pattern "[^\\t\\r\\u0008\\a\\f\\v\\\\\"]" *)

type virtual_end_section = Token.t

type imm_tok_lf_ = Token.t (* "LF" *)

type simple_char_char =
  Token.t (* pattern "[^\\n\\t\\r\\u0008\\a\\f\\v'\\\\]" *)

type imm_tok_l_ = Token.t (* "L" *)

type imm_tok_y = Token.t (* "y" *)

type imm_tok_bslashu = Token.t (* "\\U" *)

type imm_tok_un = Token.t (* "un" *)

type imm_tok_dquotb = Token.t (* "\"B" *)

type imm_tok_pat_35b22f4 = Token.t (* pattern [QRZING] *)

type imm_tok_bslash = Token.t (* "\\" *)

type imm_tok_uy = Token.t (* "uy" *)

type anon_choice_HAT_710cb5b = [
    `HAT of Token.t (* "^" *)
  | `SQUOT of Token.t (* "'" *)
]

type pat_0o = Token.t (* pattern 0[oO] *)

type imm_tok_us = Token.t (* "us" *)

type pat_213dc3e = Token.t (* pattern [0-9] *)

type escape_char = Token.t (* pattern "\\\\[\"\\'ntbrafv]" *)

type imm_tok_n = Token.t (* "n" *)

type octaldigit_imm = Token.t (* pattern [0-7] *)

type hex_digit_imm = Token.t (* pattern [0-9a-fA-F] *)

type pat_0257738 = Token.t (* pattern [!%&*+-./<=>@^|~][!%&*+-./<=>@^|~?]* *)

type non_escape_char = Token.t (* pattern "\\\\[^\"\\'ntbrafv]" *)

type access_modifier = [
    `Priv of Token.t (* "private" *)
  | `Inte of Token.t (* "internal" *)
  | `Public of Token.t (* "public" *)
]

type imm_tok_bsla = Token.t (* "\\u" *)

type float_ = Token.t

type imm_tok_pat_684220d = Token.t (* pattern "[^'\\\\]" *)

type line_comment = Token.t

type identifier = [
    `Pat_c3eb998 of pat_c3eb998
  | `Pat_9d988a2 of pat_9d988a2
]

type block_comment = (
    Token.t (* "(*" *) * block_comment_content (*tok*) * Token.t (* "*)" *)
)

type trigraph = (
    imm_tok_bslash (*tok*) * digit_char_imm (*tok*) * digit_char_imm (*tok*)
  * digit_char_imm (*tok*)
)

type int_ = (pat_213dc3e * digit_char_imm (*tok*) list (* zero or more *))

type xint = [
    `Pat_0x_rep1_hex_digit_imm of (
        pat_0x
      * hex_digit_imm (*tok*) list (* one or more *)
    )
  | `Pat_0o_rep1_octa_imm of (
        pat_0o
      * octaldigit_imm (*tok*) list (* one or more *)
    )
  | `Pat_0b_rep1_bitd_imm of (
        pat_0b
      * bitdigit_imm (*tok*) list (* one or more *)
    )
]

type symbolic_op = [
    `QMARK of Token.t (* "?" *)
  | `QMARKLTDASH of Token.t (* "?<-" *)
  | `Pat_0257738 of pat_0257738
  | `Choice_LTAT of quote_op_left
  | `Choice_ATGT of quote_op_right
]

type verbatim_string_char = [
    `Simple_str_char of simple_string_char (*tok*)
  | `Non_esc_char of non_escape_char (*tok*)
  | `BSLASH of Token.t (* "\\" *)
]

type unicodegraph_short = (
    imm_tok_bsla (*tok*) * hex_digit_imm (*tok*) * hex_digit_imm (*tok*)
  * hex_digit_imm (*tok*) * hex_digit_imm (*tok*)
)

type simple_or_escape_char = [
    `Esc_char of escape_char (*tok*)
  | `Imm_tok_pat_684220d of imm_tok_pat_684220d
]

type argument_name_spec = (
    Token.t (* "?" *) option
  * identifier
  * Token.t (* ":" *)
)

type active_pattern_op_name = [
    `BAR_id_rep1_BAR_id_BAR of (
        Token.t (* "|" *)
      * identifier
      * (Token.t (* "|" *) * identifier) list (* one or more *)
      * Token.t (* "|" *)
    )
  | `BAR_id_rep_BAR_id_BAR___BAR of (
        Token.t (* "|" *)
      * identifier
      * (Token.t (* "|" *) * identifier) list (* zero or more *)
      * Token.t (* "|" *)
      * Token.t (* "_" *)
      * Token.t (* "|" *)
    )
]

type property_or_ident = [
    `Id_DOT_id of (identifier * Token.t (* "." *) * identifier)
  | `Id of identifier
]

type as_defn = (Token.t (* "as" *) * identifier)

type long_identifier = (
    identifier
  * (Token.t (* "." *) * identifier) list (* zero or more *)
)

type type_argument = [
    `X__ of Token.t (* "_" *)
  | `SQUOT_id of (Token.t (* "'" *) * identifier)
  | `HAT_id of (Token.t (* "^" *) * identifier)
]

type static_type_argument = [
    `Choice_HAT_id of (anon_choice_HAT_710cb5b * identifier)
  | `Choice_HAT_id_rep_or_choice_HAT_id of (
        anon_choice_HAT_710cb5b
      * identifier
      * (Token.t (* "or" *) * anon_choice_HAT_710cb5b * identifier)
          list (* zero or more *)
    )
]

type anon_choice_int_06dcc46 = [ `Int of int_ | `Xint of xint ]

type ieee32 = [
    `Float_imm_tok_f of (float_ (*tok*) * imm_tok_f (*tok*))
  | `Xint_imm_tok_lf of (xint * imm_tok_lf (*tok*))
]

type prefix_op = [
    `Choice_PLUS of infix_or_prefix_op
  | `Rep1_TILDE of Token.t (* "~" *) list (* one or more *)
  | `Symb_op of symbolic_op
]

type infix_op = [
    `Choice_PLUS of infix_or_prefix_op
  | `Symb_op of symbolic_op
  | `BARBAR of Token.t (* "||" *)
  | `EQ of Token.t (* "=" *)
  | `BANGEQ of Token.t (* "!=" *)
  | `COLONEQ of Token.t (* ":=" *)
  | `COLONCOLON of Token.t (* "::" *)
  | `DOLLAR of Token.t (* "$" *)
  | `Or of Token.t (* "or" *)
  | `QMARK of Token.t (* "?" *)
]

type string_char = [
    `Simple_str_char of simple_string_char (*tok*)
  | `Esc_char of escape_char (*tok*)
  | `Non_esc_char of non_escape_char (*tok*)
  | `Trig of trigraph
  | `Unic_short of unicodegraph_short
  | `Unic_long of (
        imm_tok_bslashu (*tok*) * hex_digit_imm (*tok*)
      * hex_digit_imm (*tok*) * hex_digit_imm (*tok*) * hex_digit_imm (*tok*)
      * hex_digit_imm (*tok*) * hex_digit_imm (*tok*) * hex_digit_imm (*tok*)
      * hex_digit_imm (*tok*)
    )
]

type char_char = [
    `Simple_char_char of simple_char_char (*tok*)
  | `Esc_char of escape_char (*tok*)
  | `Trig of trigraph
  | `Unic_short of unicodegraph_short
]

type op_name = [
    `Symb_op of symbolic_op
  | `Range_op_name of range_op_name
  | `Active_pat_op_name of active_pattern_op_name
]

type string_elem = [
    `Str_char of string_char
  | `BSLASH_str_elem of (Token.t (* "\\" *) * string_elem)
]

type string_ = (
    Token.t (* "\"" *)
  * string_char list (* zero or more *)
  * imm_tok_dquot (*tok*)
)

type identifier_or_op = [
    `Id of identifier
  | `LPAR_op_name_RPAR of (Token.t (* "(" *) * op_name * Token.t (* ")" *))
  | `LPARSTARRPAR of Token.t (* "(*)" *)
]

type fsi_directive_decl = [
    `HASHr_rep_str of (Token.t (* "#r" *) * string_ list (* zero or more *))
  | `HASH_rep_str of (
        Token.t (* "#load" *)
      * string_ list (* zero or more *)
    )
]

type const = [
    `Sbyte of (anon_choice_int_06dcc46 * imm_tok_y (*tok*))
  | `Int16 of (anon_choice_int_06dcc46 * imm_tok_s (*tok*))
  | `Int32 of (anon_choice_int_06dcc46 * imm_tok_l (*tok*))
  | `Int64 of (anon_choice_int_06dcc46 * imm_tok_l_ (*tok*))
  | `Byte_40ea57d of (anon_choice_int_06dcc46 * imm_tok_uy (*tok*))
  | `Uint16 of (anon_choice_int_06dcc46 * imm_tok_us (*tok*))
  | `Uint32 of (anon_choice_int_06dcc46 * imm_tok_choice_ul)
  | `Int of int_
  | `Nati of (anon_choice_int_06dcc46 * imm_tok_n (*tok*))
  | `Unat of (anon_choice_int_06dcc46 * imm_tok_un (*tok*))
  | `Deci of ([ `Float of float_ (*tok*) | `Int of int_ ] * imm_tok_pat_m)
  | `Uint64 of (anon_choice_int_06dcc46 * imm_tok_choice_ul_)
  | `Ieee32 of ieee32
  | `Ieee64 of (xint * imm_tok_lf_ (*tok*))
  | `Bignum of (int_ * imm_tok_pat_35b22f4)
  | `Char of (Token.t (* "'" *) * char_char * imm_tok_squot (*tok*))
  | `Str of string_
  | `Verb_str of (
        Token.t (* "@\"" *)
      * verbatim_string_char list (* zero or more *)
      * imm_tok_dquot (*tok*)
    )
  | `Triple_quoted_str of (
        Token.t (* "\"\"\"" *)
      * simple_or_escape_char list (* zero or more *)
      * imm_tok_dquotdquotdquot (*tok*)
    )
  | `Byte_575c2e8 of (
        Token.t (* "\"" *)
      * string_char list (* zero or more *)
      * imm_tok_dquotb (*tok*)
    )
  | `Verb_byte of (
        Token.t (* "@\"" *)
      * verbatim_string_char list (* zero or more *)
      * imm_tok_dquotb (*tok*)
    )
  | `Byte_b1b1cb0 of (Token.t (* "'" *) * char_char * imm_tok_squotb (*tok*))
  | `False of Token.t (* "false" *)
  | `True of Token.t (* "true" *)
  | `Unit of (
        Token.t (* "(" *)
      * (virtual_open_section (*tok*) * virtual_end_section (*tok*)) option
      * Token.t (* ")" *)
    )
]

type long_identifier_or_op = [
    `Long_id of long_identifier
  | `Long_id_DOT_id_or_op of (
        long_identifier * Token.t (* "." *) * identifier_or_op
    )
  | `Id_or_op of identifier_or_op
]

type pattern_param = [
    `Const of const
  | `Long_id of long_identifier
  | `Null of Token.t (* "null" *)
]

type enum_type_case = (identifier * Token.t (* "=" *) * const)

type additional_constr_defn = (
    access_modifier option
  * Token.t (* "new" *)
  * pattern
  * as_defn
  * Token.t (* "=" *)
)

and argument_patterns = atomic_pattern list (* one or more *)

and array_pattern = [
    `LBRACKBAR_BARRBRACK of (Token.t (* "[|" *) * Token.t (* "|]" *))
  | `LBRACKBAR_pat_rep_SEMI_pat_BARRBRACK of (
        Token.t (* "[|" *)
      * pattern
      * (Token.t (* ";" *) * pattern) list (* zero or more *)
      * Token.t (* "|]" *)
    )
]

and atomic_pattern = [
    `Null of Token.t (* "null" *)
  | `X__ of Token.t (* "_" *)
  | `Const of const
  | `Long_id of long_identifier
  | `List_pat of list_pattern
  | `Record_pat of record_pattern
  | `Array_pat of array_pattern
  | `LPAR_virt_open_sect_pat_virt_end_sect_RPAR of paren_pattern
]

and attribute = (
    (attribute_target * Token.t (* ":" *)) option
  * object_construction
)

and attribute_set = (
    Token.t (* "[<" *)
  * attribute
  * (Token.t (* ";" *) * attribute) list (* zero or more *)
  * Token.t (* ">]" *)
)

and attributes = attribute_set list (* one or more *)

and base_call = [
    `Obj_cons of object_construction
  | `Obj_cons_as_id of (
        object_construction * Token.t (* "as" *) * identifier
    )
]

and comp_or_range_expression = [
    `Expres of expressions
  | `Short_comp_exp of (
        Token.t (* "for" *) * pattern * Token.t (* "in" *)
      * expression_or_range * Token.t (* "->" *) * expressions
    )
]

and constraint_ = [
    `Type_arg_COLONGT_type of (type_argument * Token.t (* ":>" *) * type_)
  | `Type_arg_COLON_null of (
        type_argument * Token.t (* ":" *) * Token.t (* "null" *)
    )
  | `Static_type_arg_COLON_LPAR_trait_member_cons_RPAR of (
        static_type_argument * Token.t (* ":" *) * Token.t (* "(" *)
      * trait_member_constraint * Token.t (* ")" *)
    )
  | `Type_arg_COLON_LPAR_new_COLON_unit_DASHGT_SQUOTT_RPAR of (
        type_argument * Token.t (* ":" *) * Token.t (* "(" *)
      * Token.t (* "new" *) * Token.t (* ":" *) * Token.t (* "unit" *)
      * Token.t (* "->" *) * Token.t (* "'T" *) * Token.t (* ")" *)
    )
  | `Type_arg_COLON_struct of (
        type_argument * Token.t (* ":" *) * Token.t (* "struct" *)
    )
  | `Type_arg_COLON_not_struct of (
        type_argument * Token.t (* ":" *) * Token.t (* "not" *)
      * Token.t (* "struct" *)
    )
  | `Type_arg_COLON_enum_LT_type_GT of (
        type_argument * Token.t (* ":" *) * Token.t (* "enum" *)
      * Token.t (* "<" *) * type_ * Token.t (* ">" *)
    )
  | `Type_arg_COLON_unma of (
        type_argument * Token.t (* ":" *) * Token.t (* "unmanaged" *)
    )
  | `Type_arg_COLON_equa of (
        type_argument * Token.t (* ":" *) * Token.t (* "equality" *)
    )
  | `Type_arg_COLON_comp of (
        type_argument * Token.t (* ":" *) * Token.t (* "comparison" *)
    )
  | `Type_arg_COLON_dele_LT_type_COMMA_type_GT of (
        type_argument * Token.t (* ":" *) * Token.t (* "delegate" *)
      * Token.t (* "<" *) * type_ * Token.t (* "," *) * type_
      * Token.t (* ">" *)
    )
]

and elif_expression = (
    Token.t (* "elif" *) * expression_inner * Token.t (* "then" *)
  * virtual_open_section (*tok*) * expressions * virtual_end_section (*tok*)
)

and else_expression = (
    Token.t (* "else" *) * virtual_open_section (*tok*) * expressions
  * virtual_end_section (*tok*)
)

and expression_inner = [
    `Line_comm of line_comment (*tok*)
  | `Blk_comm of block_comment
  | `Const of const
  | `Paren_exp of (
        Token.t (* "(" *) * virtual_open_section (*tok*) * expressions
      * virtual_end_section (*tok*) * Token.t (* ")" *)
    )
  | `Begin_end_exp of (
        Token.t (* "begin" *) * expressions * Token.t (* "end" *)
    )
  | `Long_id_or_op of long_identifier_or_op
  | `Dot_exp of (
        expression_inner * imm_tok_dot (*tok*) * long_identifier_or_op
    )
  | `Typed_exp of (
        expression_inner
      * imm_tok_lt (*tok*)
      * types option
      * Token.t (* ">" *)
    )
  | `Infix_exp of (expression_inner * infix_op * expression_inner)
  | `Index_exp of (
        expression_inner
      * imm_tok_dot (*tok*) option
      * imm_tok_lbrack (*tok*)
      * virtual_open_section (*tok*)
      * [ `Expres of expressions | `Slice_ranges of slice_ranges ]
      * virtual_end_section (*tok*)
      * Token.t (* "]" *)
    )
  | `Mutate_exp of (expression_inner * Token.t (* "<-" *) * expression_inner)
  | `Obj_inst_exp of (
        Token.t (* "new" *) * type_ * imm_tok_lpar (*tok*) * expression_inner
      * Token.t (* ")" *)
    )
  | `List_exp of (
        Token.t (* "[" *)
      * list_element option
      * Token.t (* "]" *)
    )
  | `Array_exp of (
        Token.t (* "[|" *)
      * list_element option
      * Token.t (* "|]" *)
    )
  | `Ce_exp of (
        expression_inner * Token.t (* "{" *) * virtual_open_section (*tok*)
      * comp_or_range_expression * virtual_end_section (*tok*)
      * Token.t (* "}" *)
    )
  | `Pref_exp of (
        [
            `Lazy of Token.t (* "lazy" *)
          | `Assert of Token.t (* "assert" *)
          | `Upcast of Token.t (* "upcast" *)
          | `Down of Token.t (* "downcast" *)
          | `PERC of Token.t (* "%" *)
          | `PERCPERC of Token.t (* "%%" *)
          | `Prefix_op of prefix_op
        ]
      * expression_inner
    )
  | `Brace_exp of (
        Token.t (* "{" *)
      * [
            `With_field_exp of with_field_expression
          | `Field_exp of field_expression
          | `Obj_exp of object_expression
        ]
      * Token.t (* "}" *)
    )
  | `Null of Token.t (* "null" *)
  | `Type_exp of (
        expression_inner
      * [
            `COLON of Token.t (* ":" *)
          | `COLONGT of Token.t (* ":>" *)
          | `COLONQMARK of Token.t (* ":?" *)
          | `COLONQMARKGT of Token.t (* ":?>" *)
        ]
      * type_
    )
  | `Decl_exp of (
        [
            `Choice_use_id_EQ_virt_open_sect_expres_virt_end_sect of (
                [
                    `Use of Token.t (* "use" *)
                  | `UseB of Token.t (* "use!" *)
                ]
              * identifier
              * Token.t (* "=" *)
              * virtual_open_section (*tok*)
              * expressions
              * virtual_end_section (*tok*)
            )
          | `Func_or_value_defn of function_or_value_defn
        ]
      * virtual_open_section (*tok*)
      * expressions
      * virtual_end_section (*tok*)
    )
  | `Do_exp of (
        [ `Do of Token.t (* "do" *) | `DoBANG of Token.t (* "do!" *) ]
      * virtual_open_section (*tok*)
      * expressions
      * virtual_end_section (*tok*)
    )
  | `Fun_exp of (
        Token.t (* "fun" *) * argument_patterns * Token.t (* "->" *)
      * virtual_open_section (*tok*) * expressions
      * virtual_end_section (*tok*)
    )
  | `Func_exp of (Token.t (* "function" *) * rules)
  | `If_exp of (
        Token.t (* "if" *)
      * expression_inner
      * Token.t (* "then" *)
      * expressions
      * elif_expression list (* zero or more *)
      * else_expression option
    )
  | `While_exp of (
        Token.t (* "while" *)
      * expression_inner
      * Token.t (* "do" *)
      * virtual_open_section (*tok*)
      * expressions
      * virtual_end_section (*tok*)
      * Token.t (* "done" *) option
    )
  | `For_exp of (
        Token.t (* "for" *)
      * [
            `Pat_in_choice_exp_inner of (
                pattern * Token.t (* "in" *) * expression_or_range
            )
          | `Id_EQ_exp_inner_choice_to_exp_inner of (
                identifier
              * Token.t (* "=" *)
              * expression_inner
              * [
                    `To of Token.t (* "to" *)
                  | `Downto of Token.t (* "downto" *)
                ]
              * expression_inner
            )
        ]
      * Token.t (* "do" *)
      * virtual_open_section (*tok*)
      * expressions
      * virtual_end_section (*tok*)
      * Token.t (* "done" *) option
    )
  | `Match_exp of (
        [ `Match of Token.t (* "match" *) | `Matc of Token.t (* "match!" *) ]
      * expression_inner
      * Token.t (* "with" *)
      * rules
    )
  | `Try_exp of (
        Token.t (* "try" *)
      * virtual_open_section (*tok*)
      * expressions
      * virtual_end_section (*tok*)
      * [
            `With_rules of (Token.t (* "with" *) * rules)
          | `Fina_virt_open_sect_expres_virt_end_sect of (
                Token.t (* "finally" *) * virtual_open_section (*tok*)
              * expressions * virtual_end_section (*tok*)
            )
        ]
    )
  | `Lit_exp of literal_expression
  | `Call_exp of (
        expression_inner
      * imm_tok_lpar (*tok*)
      * expressions option
      * Token.t (* ")" *)
    )
  | `Tuple_exp of (
        expression_inner
      * (Token.t (* "," *) * expression_inner) list (* one or more *)
    )
  | `App_exp of (expression_inner * expression_inner list (* one or more *))
  | `Ret_exp of (
        [ `Ret of Token.t (* "return" *) | `Retu of Token.t (* "return!" *) ]
      * expression_inner
    )
  | `Yield_exp of (
        [ `Yield of Token.t (* "yield" *) | `Yiel of Token.t (* "yield!" *) ]
      * expression_inner
    )
]

and expression_or_range = [
    `Exp_inner of expression_inner
  | `Range_exp of (
        expressions
      * Token.t (* ".." *)
      * expressions
      * (Token.t (* ".." *) * expressions) option
    )
]

and expressions = [
    `Seq_infix of (
        expression_inner
      * (virtual_end_decl (*tok*) * infix_op * expressions)
          list (* one or more *)
    )
  | `Exp_inner_rep_virt_end_decl_expres of (
        expression_inner
      * (virtual_end_decl (*tok*) * expressions) list (* zero or more *)
    )
]

and field_expression = field_initializers

and field_initializer = (
    long_identifier * Token.t (* "=" *) * virtual_open_section (*tok*)
  * expressions * virtual_end_section (*tok*)
)

and field_initializers = (
    field_initializer
  * (virtual_end_decl (*tok*) * field_initializer) list (* zero or more *)
)

and field_pattern = (long_identifier * Token.t (* "=" *) * pattern)

and function_declaration_left = (
    Token.t (* "inline" *) option
  * access_modifier option
  * identifier_or_op
  * type_arguments option
  * argument_patterns
  * (Token.t (* ":" *) * type_) option
)

and function_or_value_defn = (
    [ `Let of Token.t (* "let" *) | `LetB of Token.t (* "let!" *) ]
  * [
        `Func_or_value_defn_body of function_or_value_defn_body
      | `Rec_func_or_value_defns of (
            Token.t (* "rec" *) * function_or_value_defns
        )
    ]
)

and function_or_value_defn_body = (
    [
        `Func_decl_left of function_declaration_left
      | `Value_decl_left of value_declaration_left
    ]
  * Token.t (* "=" *)
  * virtual_open_section (*tok*)
  * expressions
  * virtual_end_section (*tok*)
)

and function_or_value_defns = (
    function_or_value_defn_body
  * (Token.t (* "and" *) * function_or_value_defn_body)
      list (* one or more *)
)

and interface_implementation = (
    Token.t (* "interface" *)
  * type_
  * object_members option
)

and interface_implementations =
  interface_implementation list (* one or more *)

and list_element = [
    `List_elemes of (
        virtual_open_section (*tok*)
      * expression_inner
      * (virtual_end_decl (*tok*) * expression_inner) list (* zero or more *)
      * virtual_end_section (*tok*)
    )
  | `Comp_or_range_exp of comp_or_range_expression
]

and list_pattern = [
    `LBRACK_RBRACK of (Token.t (* "[" *) * Token.t (* "]" *))
  | `LBRACK_pat_rep_SEMI_pat_RBRACK of (
        Token.t (* "[" *)
      * pattern
      * (Token.t (* ";" *) * pattern) list (* zero or more *)
      * Token.t (* "]" *)
    )
]

and literal_expression = [
    `LTAT_exp_inner_ATGT of (
        Token.t (* "<@" *) * expression_inner * Token.t (* "@>" *)
    )
  | `LTATAT_exp_inner_ATATGT of (
        Token.t (* "<@@" *) * expression_inner * Token.t (* "@@>" *)
    )
]

and member_defn = (
    attributes option
  * [
        `Opt_static_member_opt_choice_priv_meth_or_prop_defn of (
            Token.t (* "static" *) option
          * Token.t (* "member" *)
          * access_modifier option
          * method_or_prop_defn
        )
      | `Abst_opt_member_opt_choice_priv_member_sign of (
            Token.t (* "abstract" *)
          * Token.t (* "member" *) option
          * access_modifier option
          * member_signature
        )
      | `Over_opt_choice_priv_meth_or_prop_defn of (
            Token.t (* "override" *)
          * access_modifier option
          * method_or_prop_defn
        )
      | `Defa_opt_choice_priv_meth_or_prop_defn of (
            Token.t (* "default" *)
          * access_modifier option
          * method_or_prop_defn
        )
      | `Opt_static_val_opt_muta_opt_choice_priv_id_COLON_type of (
            Token.t (* "static" *) option
          * Token.t (* "val" *)
          * Token.t (* "mutable" *) option
          * access_modifier option
          * identifier
          * Token.t (* ":" *)
          * type_
        )
      | `Addi_constr_defn of additional_constr_defn
    ]
)

and member_defns = (
    member_defn
  * (virtual_end_decl (*tok*) * member_defn) list (* zero or more *)
)

and member_signature = (
    identifier
  * type_arguments option
  * Token.t (* ":" *)
  * type_
  * [
        `With_get of (Token.t (* "with" *) * Token.t (* "get" *))
      | `With_set of (Token.t (* "with" *) * Token.t (* "set" *))
      | `With_get_COMMA_set of (
            Token.t (* "with" *) * Token.t (* "get" *) * Token.t (* "," *)
          * Token.t (* "set" *)
        )
      | `With_set_COMMA_get of (
            Token.t (* "with" *) * Token.t (* "set" *) * Token.t (* "," *)
          * Token.t (* "get" *)
        )
    ]
      option
)

and method_defn = [
  `Prop_or_id_pat_EQ_virt_open_sect_expres_virt_end_sect of (
      property_or_ident * pattern * Token.t (* "=" *)
    * virtual_open_section (*tok*) * expressions
    * virtual_end_section (*tok*)
  )
]

and method_or_prop_defn = [
    `Prop_or_id_with_virt_open_sect_func_or_value_defns_virt_end_sect of (
        property_or_ident * Token.t (* "with" *)
      * virtual_open_section (*tok*) * function_or_value_defns
      * virtual_end_section (*tok*)
    )
  | `Meth_defn of method_defn
  | `Prop_defn of (
        property_or_ident
      * Token.t (* "=" *)
      * virtual_open_section (*tok*)
      * expressions
      * virtual_end_section (*tok*)
      * (
            Token.t (* "with" *)
          * [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Get_COMMA_set of (
                    Token.t (* "get" *) * Token.t (* "," *)
                  * Token.t (* "set" *)
                )
              | `Set_COMMA_get of (
                    Token.t (* "set" *) * Token.t (* "," *)
                  * Token.t (* "get" *)
                )
            ]
        )
          option
    )
]

and object_construction = (type_ * expressions option)

and object_expression = (
    Token.t (* "new" *) * base_call * virtual_open_section (*tok*)
  * object_members * interface_implementations * virtual_end_section (*tok*)
)

and object_members = (
    Token.t (* "with" *) * virtual_open_section (*tok*) * member_defns
  * virtual_end_section (*tok*)
)

and paren_pattern = (
    Token.t (* "(" *) * virtual_open_section (*tok*) * pattern
  * virtual_end_section (*tok*) * Token.t (* ")" *)
)

and pattern = [
    `Null of Token.t (* "null" *)
  | `X__ of Token.t (* "_" *)
  | `Const of const
  | `Id_pat of (long_identifier * pattern_param option * pattern option)
  | `As_pat of (pattern * Token.t (* "as" *) * identifier)
  | `Disj_pat of (pattern * Token.t (* "|" *) * pattern)
  | `Conj_pat of (pattern * Token.t (* "&" *) * pattern)
  | `Cons_pat of (pattern * Token.t (* "::" *) * pattern)
  | `Repeat_pat of (
        pattern
      * Token.t (* "," *)
      * (virtual_end_decl (*tok*) * pattern * Token.t (* "," *))
          list (* zero or more *)
      * pattern
    )
  | `Paren_pat of paren_pattern
  | `List_pat of list_pattern
  | `Array_pat of array_pattern
  | `Record_pat of record_pattern
  | `Typed_pat of (pattern * Token.t (* ":" *) * type_)
  | `Attr_pat of (attributes * pattern)
]

and record_pattern = (
    Token.t (* "{" *)
  * field_pattern
  * (Token.t (* ";" *) * field_pattern) list (* zero or more *)
)

and rule = (
    pattern * Token.t (* "->" *) * virtual_open_section (*tok*) * expressions
  * virtual_end_section (*tok*)
)

and rules = (
    virtual_open_section (*tok*)
  * Token.t (* "|" *) option
  * rule
  * (Token.t (* "|" *) * rule) list (* zero or more *)
  * virtual_end_section (*tok*)
)

and slice_range = [
    `Slice_range_spec of slice_range_special
  | `Expres of expressions
  | `STAR of Token.t (* "*" *)
]

and slice_range_special = [
    `Expres_DOTDOT of (expressions * Token.t (* ".." *))
  | `DOTDOT_expres of (Token.t (* ".." *) * expressions)
  | `Expres_DOTDOT_expres of (expressions * Token.t (* ".." *) * expressions)
]

and slice_ranges = (
    slice_range
  * (Token.t (* "," *) * slice_range) list (* zero or more *)
)

and trait_member_constraint = (
    Token.t (* "static" *) option
  * Token.t (* "member" *)
  * identifier
  * Token.t (* ":" *)
  * type_
)

and type_ = [
    `Long_id of long_identifier
  | `Long_id_LT_opt_type_attris_GT of (
        long_identifier
      * Token.t (* "<" *)
      * type_attributes option
      * Token.t (* ">" *)
    )
  | `LPAR_type_RPAR of (Token.t (* "(" *) * type_ * Token.t (* ")" *))
  | `Type_DASHGT_type of (type_ * Token.t (* "->" *) * type_)
  | `Type_rep1_STAR_type of (
        type_
      * (Token.t (* "*" *) * type_) list (* one or more *)
    )
  | `Type_long_id of (type_ * long_identifier)
  | `Type_LBRACK_rep_COMMA_RBRACK of (
        type_
      * Token.t (* "[" *)
      * Token.t (* "," *) list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `Type_type_arg_defn of (type_ * type_argument_defn)
  | `Type_arg of type_argument
  | `Type_arg_COLONGT_type of (type_argument * Token.t (* ":>" *) * type_)
  | `Imm_tok_hash_type of (imm_tok_hash (*tok*) * type_)
]

and type_argument_constraints = (
    Token.t (* "when" *)
  * constraint_
  * (Token.t (* "and" *) * constraint_) list (* zero or more *)
)

and type_argument_defn = (attributes option * type_argument)

and type_arguments = (
    Token.t (* "<" *)
  * type_argument_defn
  * (Token.t (* "," *) * type_argument_defn) list (* zero or more *)
  * type_argument_constraints option
  * Token.t (* ">" *)
)

and type_attribute = [ `Type of type_ ]

and type_attributes = (
    type_attribute
  * (Token.t (* "," *) * type_attribute) list (* zero or more *)
)

and types = (type_ * (Token.t (* "," *) * type_) list (* one or more *))

and value_declaration_left = (
    Token.t (* "mutable" *) option
  * access_modifier option
  * pattern
  * type_arguments option
  * (Token.t (* ":" *) * type_) option
)

and with_field_expression = (
    expressions * Token.t (* "with" *) * virtual_open_section (*tok*)
  * field_expression * virtual_end_section (*tok*)
)

type enum_type_cases = (
    Token.t (* "|" *) option
  * enum_type_case
  * (virtual_end_decl (*tok*) * Token.t (* "|" *) * enum_type_case)
      list (* zero or more *)
)

type type_defn_elements = [
    `Member_defns of member_defns
  | `Inte_imples of interface_implementations
]

type delegate_signature = (
    Token.t (* "delegate" *) * Token.t (* "of" *) * type_
)

type type_name = (
    attributes option
  * access_modifier option
  * [
        `Id_opt_type_args of (identifier * type_arguments option)
      | `Opt_type_arg_id of (type_argument option * identifier)
    ]
)

type static_parameter_value = [
    `Const of const
  | `Const_expres of (const * expressions)
]

type class_inherits_decl = (
    Token.t (* "inherit" *)
  * type_
  * virtual_open_section (*tok*)
  * expressions option
  * virtual_end_section (*tok*)
)

type record_field = (
    attributes option
  * Token.t (* "mutable" *) option
  * access_modifier option
  * identifier
  * Token.t (* ":" *)
  * type_
)

type argument_spec = (attributes option * argument_name_spec option * type_)

type union_type_field = [
    `Type of type_
  | `Id_COLON_type of (identifier * Token.t (* ":" *) * type_)
]

type do_ = (
    Token.t (* "do" *) * virtual_open_section (*tok*) * expressions
  * virtual_end_section (*tok*)
)

type simple_pattern = [
    `Id of identifier
  | `Simple_pat_COLON_type of (simple_pattern * Token.t (* ":" *) * type_)
]

type type_extension_elements = [
    `With_virt_open_sect_type_defn_elemes_virt_end_sect of (
        Token.t (* "with" *) * virtual_open_section (*tok*)
      * type_defn_elements * virtual_end_section (*tok*)
    )
  | `Type_defn_elemes of type_defn_elements
]

type additional_constr_init_expr = [
    `LCURL_class_inhers_decl_field_initis_RCURL of (
        Token.t (* "{" *) * class_inherits_decl * field_expression
      * Token.t (* "}" *)
    )
  | `New_type_expres of (Token.t (* "new" *) * type_ * expressions)
]

type record_fields = (
    record_field
  * (virtual_end_decl (*tok*) * record_field) list (* zero or more *)
  * Token.t (* ";" *) option
)

type union_type_fields = (
    union_type_field
  * (Token.t (* "*" *) * union_type_field) list (* zero or more *)
)

type value_declaration = [
    `Func_or_value_defn of function_or_value_defn
  | `Do of do_
]

type primary_constr_args = (
    attributes option
  * access_modifier option
  * Token.t (* "(" *)
  * (
        simple_pattern
      * (Token.t (* "," *) * simple_pattern) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type additional_constr_expr = [
    `Addi_constr_expr_SEMI_addi_constr_expr of (
        additional_constr_expr * Token.t (* ";" *) * additional_constr_expr
    )
  | `Addi_constr_expr_then_expres of (
        additional_constr_expr * Token.t (* "then" *) * expressions
    )
  | `If_expres_then_addi_constr_expr_else_addi_constr_expr of (
        Token.t (* "if" *) * expressions * Token.t (* "then" *)
      * additional_constr_expr * Token.t (* "else" *)
      * additional_constr_expr
    )
  | `Let_func_or_value_defn_body_in_addi_constr_expr of (
        Token.t (* "let" *) * function_or_value_defn_body
      * Token.t (* "in" *) * additional_constr_expr
    )
  | `Addi_constr_init_expr of additional_constr_init_expr
]

type union_type_case = (
    attributes option
  * [
        `Id of identifier
      | `Id_of_union_type_fields of (
            identifier * Token.t (* "of" *) * union_type_fields
        )
      | `Id_COLON_type of (identifier * Token.t (* ":" *) * type_)
    ]
)

type class_type_body_inner = [
    `Class_inhers_decl of class_inherits_decl
  | `Class_func_or_value_defn of (
        attributes option
      * Token.t (* "static" *) option
      * [
            `Func_or_value_defn of function_or_value_defn
          | `Do_virt_open_sect_expres_virt_end_sect of do_
        ]
    )
  | `Type_defn_elemes of type_defn_elements
]

type union_type_cases = (
    Token.t (* "|" *) option
  * union_type_case
  * (Token.t (* "|" *) * union_type_case) list (* zero or more *)
)

type class_type_body = (
    virtual_open_section (*tok*)
  * class_type_body_inner
  * (virtual_end_decl (*tok*) * class_type_body_inner)
      list (* zero or more *)
  * virtual_end_section (*tok*)
)

type type_defn_body = [
    `Dele_type_defn of (
        type_name * Token.t (* "=" *) * virtual_open_section (*tok*)
      * delegate_signature * virtual_end_section (*tok*)
    )
  | `Record_type_defn of (
        type_name
      * Token.t (* "=" *)
      * virtual_open_section (*tok*)
      * Token.t (* "{" *)
      * virtual_open_section (*tok*)
      * record_fields
      * virtual_end_section (*tok*)
      * Token.t (* "}" *)
      * type_extension_elements option
      * virtual_end_section (*tok*)
    )
  | `Union_type_defn of (
        type_name
      * Token.t (* "=" *)
      * virtual_open_section (*tok*)
      * union_type_cases
      * type_extension_elements option
      * virtual_end_section (*tok*)
    )
  | `Anon_type_defn of (
        type_name * primary_constr_args * Token.t (* "=" *)
      * virtual_open_section (*tok*) * class_type_body
      * virtual_end_section (*tok*)
    )
  | `Enum_type_defn of (
        type_name * Token.t (* "=" *) * virtual_open_section (*tok*)
      * enum_type_cases * virtual_end_section (*tok*)
    )
  | `Type_abbrev_defn of (
        type_name * Token.t (* "=" *) * virtual_open_section (*tok*) * type_
      * virtual_end_section (*tok*)
    )
  | `Type_exte of (type_name * type_extension_elements)
]

type module_elem = [
    `Blk_comm of block_comment
  | `Line_comm of line_comment (*tok*)
  | `Value_decl of value_declaration
  | `Module_defn of (
        attributes option
      * Token.t (* "module" *)
      * access_modifier option
      * identifier
      * Token.t (* "=" *)
      * virtual_open_section (*tok*)
      * module_elem list (* one or more *)
      * virtual_end_section (*tok*)
    )
  | `Module_abbrev of (
        Token.t (* "module" *) * identifier * Token.t (* "=" *)
      * virtual_open_section (*tok*) * long_identifier
      * virtual_end_section (*tok*)
    )
  | `Import_decl of (Token.t (* "open" *) * long_identifier)
  | `Comp_dire_decl of (
        Token.t (* "#nowarn" *)
      * string_ list (* zero or more *)
    )
  | `Fsi_dire_decl of fsi_directive_decl
  | `Type_defi of (
        attributes option
      * Token.t (* "type" *)
      * type_defn_body
      * (attributes option * Token.t (* "and" *) * type_defn_body)
          list (* zero or more *)
    )
]

type file = [
    `Named_module of (
        Token.t (* "module" *)
      * access_modifier option
      * long_identifier
      * module_elem list (* zero or more *)
    )
  | `Name of (
        Token.t (* "namespace" *)
      * [ `Global of Token.t (* "global" *) | `Long_id of long_identifier ]
      * module_elem list (* zero or more *)
    )
  | `Rep1_choice_blk_comm of module_elem list (* one or more *)
]

type newline (* inlined *) = Token.t (* pattern \r?\n *)

type unit_ (* inlined *) = (
    Token.t (* "(" *)
  * (virtual_open_section (*tok*) * virtual_end_section (*tok*)) option
  * Token.t (* ")" *)
)

type unicodegraph_long (* inlined *) = (
    imm_tok_bslashu (*tok*) * hex_digit_imm (*tok*) * hex_digit_imm (*tok*)
  * hex_digit_imm (*tok*) * hex_digit_imm (*tok*) * hex_digit_imm (*tok*)
  * hex_digit_imm (*tok*) * hex_digit_imm (*tok*) * hex_digit_imm (*tok*)
)

type bignum (* inlined *) = (int_ * imm_tok_pat_35b22f4)

type decimal (* inlined *) = (
    [ `Float of float_ (*tok*) | `Int of int_ ]
  * imm_tok_pat_m
)

type ieee64 (* inlined *) = (xint * imm_tok_lf_ (*tok*))

type verbatim_bytearray (* inlined *) = (
    Token.t (* "@\"" *)
  * verbatim_string_char list (* zero or more *)
  * imm_tok_dquotb (*tok*)
)

type verbatim_string (* inlined *) = (
    Token.t (* "@\"" *)
  * verbatim_string_char list (* zero or more *)
  * imm_tok_dquot (*tok*)
)

type triple_quoted_string (* inlined *) = (
    Token.t (* "\"\"\"" *)
  * simple_or_escape_char list (* zero or more *)
  * imm_tok_dquotdquotdquot (*tok*)
)

type import_decl (* inlined *) = (Token.t (* "open" *) * long_identifier)

type module_abbrev (* inlined *) = (
    Token.t (* "module" *) * identifier * Token.t (* "=" *)
  * virtual_open_section (*tok*) * long_identifier
  * virtual_end_section (*tok*)
)

type byte (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_uy (*tok*))

type int32 (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_l (*tok*))

type int16 (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_s (*tok*))

type int64 (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_l_ (*tok*))

type uint16 (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_us (*tok*))

type uint32 (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_choice_ul)

type nativeint (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_n (*tok*))

type unativeint (* inlined *) = (
    anon_choice_int_06dcc46 * imm_tok_un (*tok*)
)

type sbyte (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_y (*tok*))

type uint64 (* inlined *) = (anon_choice_int_06dcc46 * imm_tok_choice_ul_)

type bytearray (* inlined *) = (
    Token.t (* "\"" *)
  * string_char list (* zero or more *)
  * imm_tok_dquotb (*tok*)
)

type char (* inlined *) = (
    Token.t (* "'" *) * char_char * imm_tok_squot (*tok*)
)

type bytechar (* inlined *) = (
    Token.t (* "'" *) * char_char * imm_tok_squotb (*tok*)
)

type compiler_directive_decl (* inlined *) = (
    Token.t (* "#nowarn" *)
  * string_ list (* zero or more *)
)

type application_expression (* inlined *) = (
    expression_inner
  * expression_inner list (* one or more *)
)

type array_expression (* inlined *) = (
    Token.t (* "[|" *)
  * list_element option
  * Token.t (* "|]" *)
)

type as_pattern (* inlined *) = (pattern * Token.t (* "as" *) * identifier)

type attribute_pattern (* inlined *) = (attributes * pattern)

type begin_end_expression (* inlined *) = (
    Token.t (* "begin" *) * expressions * Token.t (* "end" *)
)

type brace_expression (* inlined *) = (
    Token.t (* "{" *)
  * [
        `With_field_exp of with_field_expression
      | `Field_exp of field_expression
      | `Obj_exp of object_expression
    ]
  * Token.t (* "}" *)
)

type call_expression (* inlined *) = (
    expression_inner
  * imm_tok_lpar (*tok*)
  * expressions option
  * Token.t (* ")" *)
)

type ce_expression (* inlined *) = (
    expression_inner * Token.t (* "{" *) * virtual_open_section (*tok*)
  * comp_or_range_expression * virtual_end_section (*tok*)
  * Token.t (* "}" *)
)

type conjunct_pattern (* inlined *) = (pattern * Token.t (* "&" *) * pattern)

type cons_pattern (* inlined *) = (pattern * Token.t (* "::" *) * pattern)

type declaration_expression (* inlined *) = (
    [
        `Choice_use_id_EQ_virt_open_sect_expres_virt_end_sect of (
            [ `Use of Token.t (* "use" *) | `UseB of Token.t (* "use!" *) ]
          * identifier
          * Token.t (* "=" *)
          * virtual_open_section (*tok*)
          * expressions
          * virtual_end_section (*tok*)
        )
      | `Func_or_value_defn of function_or_value_defn
    ]
  * virtual_open_section (*tok*)
  * expressions
  * virtual_end_section (*tok*)
)

type disjunct_pattern (* inlined *) = (pattern * Token.t (* "|" *) * pattern)

type do_expression (* inlined *) = (
    [ `Do of Token.t (* "do" *) | `DoBANG of Token.t (* "do!" *) ]
  * virtual_open_section (*tok*)
  * expressions
  * virtual_end_section (*tok*)
)

type dot_expression (* inlined *) = (
    expression_inner * imm_tok_dot (*tok*) * long_identifier_or_op
)

type for_expression (* inlined *) = (
    Token.t (* "for" *)
  * [
        `Pat_in_choice_exp_inner of (
            pattern * Token.t (* "in" *) * expression_or_range
        )
      | `Id_EQ_exp_inner_choice_to_exp_inner of (
            identifier
          * Token.t (* "=" *)
          * expression_inner
          * [ `To of Token.t (* "to" *) | `Downto of Token.t (* "downto" *) ]
          * expression_inner
        )
    ]
  * Token.t (* "do" *)
  * virtual_open_section (*tok*)
  * expressions
  * virtual_end_section (*tok*)
  * Token.t (* "done" *) option
)

type fun_expression (* inlined *) = (
    Token.t (* "fun" *) * argument_patterns * Token.t (* "->" *)
  * virtual_open_section (*tok*) * expressions * virtual_end_section (*tok*)
)

type function_expression (* inlined *) = (Token.t (* "function" *) * rules)

type identifier_pattern (* inlined *) = (
    long_identifier
  * pattern_param option
  * pattern option
)

type if_expression (* inlined *) = (
    Token.t (* "if" *)
  * expression_inner
  * Token.t (* "then" *)
  * expressions
  * elif_expression list (* zero or more *)
  * else_expression option
)

type index_expression (* inlined *) = (
    expression_inner
  * imm_tok_dot (*tok*) option
  * imm_tok_lbrack (*tok*)
  * virtual_open_section (*tok*)
  * [ `Expres of expressions | `Slice_ranges of slice_ranges ]
  * virtual_end_section (*tok*)
  * Token.t (* "]" *)
)

type infix_expression (* inlined *) = (
    expression_inner * infix_op * expression_inner
)

type list_elements (* inlined *) = (
    virtual_open_section (*tok*)
  * expression_inner
  * (virtual_end_decl (*tok*) * expression_inner) list (* zero or more *)
  * virtual_end_section (*tok*)
)

type list_expression (* inlined *) = (
    Token.t (* "[" *)
  * list_element option
  * Token.t (* "]" *)
)

type match_expression (* inlined *) = (
    [ `Match of Token.t (* "match" *) | `Matc of Token.t (* "match!" *) ]
  * expression_inner
  * Token.t (* "with" *)
  * rules
)

type mutate_expression (* inlined *) = (
    expression_inner * Token.t (* "<-" *) * expression_inner
)

type object_instantiation_expression (* inlined *) = (
    Token.t (* "new" *) * type_ * imm_tok_lpar (*tok*) * expression_inner
  * Token.t (* ")" *)
)

type paren_expression (* inlined *) = (
    Token.t (* "(" *) * virtual_open_section (*tok*) * expressions
  * virtual_end_section (*tok*) * Token.t (* ")" *)
)

type prefixed_expression (* inlined *) = (
    [
        `Lazy of Token.t (* "lazy" *)
      | `Assert of Token.t (* "assert" *)
      | `Upcast of Token.t (* "upcast" *)
      | `Down of Token.t (* "downcast" *)
      | `PERC of Token.t (* "%" *)
      | `PERCPERC of Token.t (* "%%" *)
      | `Prefix_op of prefix_op
    ]
  * expression_inner
)

type property_defn (* inlined *) = (
    property_or_ident
  * Token.t (* "=" *)
  * virtual_open_section (*tok*)
  * expressions
  * virtual_end_section (*tok*)
  * (
        Token.t (* "with" *)
      * [
            `Get of Token.t (* "get" *)
          | `Set of Token.t (* "set" *)
          | `Get_COMMA_set of (
                Token.t (* "get" *) * Token.t (* "," *) * Token.t (* "set" *)
            )
          | `Set_COMMA_get of (
                Token.t (* "set" *) * Token.t (* "," *) * Token.t (* "get" *)
            )
        ]
    )
      option
)

type range_expression (* inlined *) = (
    expressions
  * Token.t (* ".." *)
  * expressions
  * (Token.t (* ".." *) * expressions) option
)

type repeat_pattern (* inlined *) = (
    pattern
  * Token.t (* "," *)
  * (virtual_end_decl (*tok*) * pattern * Token.t (* "," *))
      list (* zero or more *)
  * pattern
)

type return_expression (* inlined *) = (
    [ `Ret of Token.t (* "return" *) | `Retu of Token.t (* "return!" *) ]
  * expression_inner
)

type seq_expressions (* inlined *) = (
    expression_inner
  * (virtual_end_decl (*tok*) * expressions) list (* zero or more *)
)

type seq_infix (* inlined *) = (
    expression_inner
  * (virtual_end_decl (*tok*) * infix_op * expressions)
      list (* one or more *)
)

type short_comp_expression (* inlined *) = (
    Token.t (* "for" *) * pattern * Token.t (* "in" *) * expression_or_range
  * Token.t (* "->" *) * expressions
)

type try_expression (* inlined *) = (
    Token.t (* "try" *)
  * virtual_open_section (*tok*)
  * expressions
  * virtual_end_section (*tok*)
  * [
        `With_rules of (Token.t (* "with" *) * rules)
      | `Fina_virt_open_sect_expres_virt_end_sect of (
            Token.t (* "finally" *) * virtual_open_section (*tok*)
          * expressions * virtual_end_section (*tok*)
        )
    ]
)

type tuple_expression (* inlined *) = (
    expression_inner
  * (Token.t (* "," *) * expression_inner) list (* one or more *)
)

type typecast_expression (* inlined *) = (
    expression_inner
  * [
        `COLON of Token.t (* ":" *)
      | `COLONGT of Token.t (* ":>" *)
      | `COLONQMARK of Token.t (* ":?" *)
      | `COLONQMARKGT of Token.t (* ":?>" *)
    ]
  * type_
)

type typed_expression (* inlined *) = (
    expression_inner
  * imm_tok_lt (*tok*)
  * types option
  * Token.t (* ">" *)
)

type typed_pattern (* inlined *) = (pattern * Token.t (* ":" *) * type_)

type while_expression (* inlined *) = (
    Token.t (* "while" *)
  * expression_inner
  * Token.t (* "do" *)
  * virtual_open_section (*tok*)
  * expressions
  * virtual_end_section (*tok*)
  * Token.t (* "done" *) option
)

type yield_expression (* inlined *) = (
    [ `Yield of Token.t (* "yield" *) | `Yiel of Token.t (* "yield!" *) ]
  * expression_inner
)

type interface_spec (* inlined *) = (Token.t (* "interface" *) * type_)

type atomic_type (* inlined *) = [
    `HASH_type of (Token.t (* "#" *) * type_)
  | `Type_arg of type_argument
  | `LPAR_type_RPAR of (Token.t (* "(" *) * type_ * Token.t (* ")" *))
  | `Long_id of long_identifier
  | `Long_id_LT_type_attris_GT of (
        long_identifier * Token.t (* "<" *) * type_attributes
      * Token.t (* ">" *)
    )
]

type delegate_type_defn (* inlined *) = (
    type_name * Token.t (* "=" *) * virtual_open_section (*tok*)
  * delegate_signature * virtual_end_section (*tok*)
)

type enum_type_defn (* inlined *) = (
    type_name * Token.t (* "=" *) * virtual_open_section (*tok*)
  * enum_type_cases * virtual_end_section (*tok*)
)

type type_abbrev_defn (* inlined *) = (
    type_name * Token.t (* "=" *) * virtual_open_section (*tok*) * type_
  * virtual_end_section (*tok*)
)

type static_parameter (* inlined *) = [
    `Static_param_value of static_parameter_value
  | `Id_EQ_static_param_value of (
        Token.t (* "id" *) * Token.t (* "=" *) * static_parameter_value
    )
]

type arguments_spec (* inlined *) = (
    argument_spec
  * (Token.t (* "*" *) * argument_spec) list (* zero or more *)
)

type class_function_or_value_defn (* inlined *) = (
    attributes option
  * Token.t (* "static" *) option
  * [
        `Func_or_value_defn of function_or_value_defn
      | `Do_virt_open_sect_expres_virt_end_sect of do_
    ]
)

type type_extension (* inlined *) = (type_name * type_extension_elements)

type record_type_defn (* inlined *) = (
    type_name
  * Token.t (* "=" *)
  * virtual_open_section (*tok*)
  * Token.t (* "{" *)
  * virtual_open_section (*tok*)
  * record_fields
  * virtual_end_section (*tok*)
  * Token.t (* "}" *)
  * type_extension_elements option
  * virtual_end_section (*tok*)
)

type union_type_defn (* inlined *) = (
    type_name
  * Token.t (* "=" *)
  * virtual_open_section (*tok*)
  * union_type_cases
  * type_extension_elements option
  * virtual_end_section (*tok*)
)

type anon_type_defn (* inlined *) = (
    type_name * primary_constr_args * Token.t (* "=" *)
  * virtual_open_section (*tok*) * class_type_body
  * virtual_end_section (*tok*)
)

type type_definition (* inlined *) = (
    attributes option
  * Token.t (* "type" *)
  * type_defn_body
  * (attributes option * Token.t (* "and" *) * type_defn_body)
      list (* zero or more *)
)

type module_defn (* inlined *) = (
    attributes option
  * Token.t (* "module" *)
  * access_modifier option
  * identifier
  * Token.t (* "=" *)
  * virtual_open_section (*tok*)
  * module_elem list (* one or more *)
  * virtual_end_section (*tok*)
)

type namespace (* inlined *) = (
    Token.t (* "namespace" *)
  * [ `Global of Token.t (* "global" *) | `Long_id of long_identifier ]
  * module_elem list (* zero or more *)
)

type named_module (* inlined *) = (
    Token.t (* "module" *)
  * access_modifier option
  * long_identifier
  * module_elem list (* zero or more *)
)

type extra

type extras = extra list
